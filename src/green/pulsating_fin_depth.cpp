
// Include general usage libraries
#include <iostream>

// Include general usage scientific libraries
#include <cmath>

// Include local modules
#include "../config.hpp"
#include "../math/math_tools.hpp"
#include "pulsating_fin_depth.hpp"
#include "../math/special_math.hpp"

// Include namespaces
using namespace std;
using namespace std::literals::complex_literals;


cuscomplex john_series(cusfloat R, cusfloat z, cusfloat zeta, cusfloat h, cusfloat nu,
                    cusfloat k0, int num_kn, cusfloat* kn)
{
    /**
     * @brief John series representation of the finite water depth Green function
     * 
     * This is an eigenfunction expasion generated by Fritz John in the article
     * "On the Motion of Floating Bodies II". In the current implementation the 
     * series has been modified to work withou hyperbolic cosines in order to 
     * reduce numerical problems with big number. It is explained at:
     * "Consistent expression for the free-surfae Green function in finite water
     * depth" - Ed Mackay.
     * 
     * \param R Horizontal distance between source and the field point
     * \param z Vertical coordinate of the field point
     * \param zeta Vertical coordinate of the source point
     * \param h Water depth
     * \param nu Wave number at infinite water depth (w^2/g)
     * \param k0 Real root of the dispersion equation at water depth h
     * \param num_kn Number of imaginary roots
     * \param kn Imaginary roots of the dispersion equation at water depth h
     * \return value of the Jonh series
     */

    // Calculate vertical distances between the source and
    // the field point
    cusfloat v3 = abs(z+zeta);
    cusfloat v4 = z-zeta+2*h;
    cusfloat v5 = zeta-z+2*h;
    cusfloat v6 = z+zeta+4*h;

    // Calcuate real root series part
    cusfloat k0nu = pow2s(k0)-pow2s(nu);
    cusfloat k0r = k0*R;
    cusfloat expsum = (
                        + exp(-k0*v3)
                        + exp(-k0*v4)
                        + exp(-k0*v5)
                        + exp(-k0*v6)
                    );
    cusfloat c_real = -2*PI*pow2s(k0)*expsum/((k0nu*h+nu)*pow2s(1+exp(-2*k0*h)));
    cuscomplex sol = c_real*(bessely0(k0r)+besselj0(k0r)*1i);

    // Calculate imag root series part
    cusfloat c_imag = 0.0;
    cusfloat ci = 0.0;
    int count_k = 0;
    cusfloat kni = 0.0;
    cusfloat knnu = 0.0;
    cusfloat zetah = zeta+h;
    cusfloat zh = z+h;
    while (true)
    {
        // Calculate i term of the series
        kni = kn[count_k];
        knnu = pow2s(kni)+pow2s(nu);
        ci = 4*knnu*cos(kni*zh)*cos(kni*zetah)*besselk0(kni*R)/(knnu*h-nu);
        c_imag += ci;

        // Check for convergence
        if (abs(ci)<EPS_PRECISION)
        {
            break;
        }

        // Check for the limit in imaginary roots
        if (count_k > (num_kn-2))
        {
            std::cerr << "Jonh series could not converge up to the precision required with" << std::endl;
            std::cerr << "Input parameters:"  << std::endl;
            std::cerr << "  - R/h: " << R/h << std::endl;
            std::cerr << "  - R: " << R << std::endl;
            std::cerr << "  - z: " << z << std::endl;
            std::cerr << "  - zeta: " << zeta << std::endl;
            std::cerr << "  - h: " << h << std::endl;
            std::cerr << "  - nu: " << nu << std::endl;
            std::cerr << "  - k0: " << k0 << std::endl;
            std::cerr << "  - num_kn: " << num_kn << std::endl;
            std::cerr << "* Current term value is: " << ci << std::endl;
            throw std::runtime_error("Jonh series value could not converge. See log file for details.");
        }

        // Update counter
        count_k++;
    }
    sol += c_imag;

    return sol;
}